<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/internal/db/ssms_manager.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/db/ssms_manager.go" />
              <option name="originalContent" value="package db&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;database/sql&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;log&quot;&#10;&#9;&quot;net/url&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;strconv&quot;&#10;&#9;&quot;sync&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;api-dansort/internal/config&quot;&#10;&#9;&quot;api-dansort/internal/models&quot;&#10;&#10;&#9;&quot;github.com/joho/godotenv&quot;&#10;&#9;_ &quot;github.com/microsoft/go-mssqldb&quot;&#10;)&#10;&#10;// Manager encapsula un pool de conexiones a SQL Server y expone helpers seguros&#10;// para ejecutar consultas dentro del proyecto.&#10;type Manager struct {&#10;&#9;db        *sql.DB&#10;&#9;closeOnce sync.Once&#10;}&#10;&#10;var (&#10;&#9;managerOnce     sync.Once&#10;&#9;managerInstance *Manager&#10;&#9;managerErr      error&#10;)&#10;&#10;// GetManager devuelve una instancia singleton del gestor de base de datos.&#10;// La primera invocación crea el pool utilizando la configuración proveniente&#10;// de variables de entorno.&#10;func GetManager(ctx context.Context) (*Manager, error) {&#10;&#9;managerOnce.Do(func() {&#10;&#9;&#9;var mgr *Manager&#10;&#9;&#9;mgr, managerErr = newManager(ctx)&#10;&#9;&#9;if managerErr == nil {&#10;&#9;&#9;&#9;managerInstance = mgr&#10;&#9;&#9;}&#10;&#9;})&#10;&#10;&#9;if managerErr != nil {&#10;&#9;&#9;return nil, managerErr&#10;&#9;}&#10;&#9;return managerInstance, nil&#10;}&#10;&#10;// GetManagerWithConfig devuelve una instancia del gestor usando configuración YAML&#10;// No usa singleton, crea una nueva instancia cada vez&#10;func GetManagerWithConfig(ctx context.Context, cfg config.SQLServerConfig) (*Manager, error) {&#10;&#9;return newManagerWithConfig(ctx, cfg, &quot;&quot;)&#10;}&#10;&#10;// GetManagerWithConfigAndLabel crea un manager con label personalizada para logs&#10;func GetManagerWithConfigAndLabel(ctx context.Context, cfg config.SQLServerConfig, label string) (*Manager, error) {&#10;&#9;return newManagerWithConfig(ctx, cfg, label)&#10;}&#10;&#10;// newManagerWithConfig es la función interna que crea el manager&#10;func newManagerWithConfig(ctx context.Context, cfg config.SQLServerConfig, label string) (*Manager, error) {&#10;&#9;// Construir URL con encoding apropiado para caracteres especiales&#10;&#9;query := url.Values{}&#10;&#9;if cfg.Database != &quot;&quot; {&#10;&#9;&#9;query.Add(&quot;database&quot;, cfg.Database)&#10;&#9;}&#10;&#9;query.Add(&quot;encrypt&quot;, cfg.Encrypt)&#10;&#9;query.Add(&quot;TrustServerCertificate&quot;, fmt.Sprintf(&quot;%t&quot;, cfg.TrustCert))&#10;&#10;&#9;appName := cfg.AppName&#10;&#9;if label != &quot;&quot; {&#10;&#9;&#9;appName = fmt.Sprintf(&quot;%s-%s&quot;, cfg.AppName, label)&#10;&#9;}&#10;&#9;query.Add(&quot;app name&quot;, appName)&#10;&#9;query.Add(&quot;connection timeout&quot;, fmt.Sprintf(&quot;%d&quot;, cfg.ConnectTimeout))&#10;&#10;&#9;u := &amp;url.URL{&#10;&#9;&#9;Scheme:   &quot;sqlserver&quot;,&#10;&#9;&#9;User:     url.UserPassword(cfg.User, cfg.Password),&#10;&#9;&#9;Host:     fmt.Sprintf(&quot;%s:%d&quot;, cfg.Host, cfg.Port),&#10;&#9;&#9;RawQuery: query.Encode(),&#10;&#9;}&#10;&#10;&#9;connString := u.String()&#10;&#10;&#9;db, err := sql.Open(&quot;sqlserver&quot;, connString)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;db: no fue posible crear el pool de conexiones: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;// Configurar pool&#10;&#9;db.SetMaxOpenConns(cfg.MaxConns)&#10;&#9;db.SetMaxIdleConns(cfg.MinConns)&#10;&#10;&#9;if cfg.MaxConnLifetime != &quot;&quot; {&#10;&#9;&#9;duration, _ := time.ParseDuration(cfg.MaxConnLifetime)&#10;&#9;&#9;db.SetConnMaxLifetime(duration)&#10;&#9;}&#10;&#9;if cfg.MaxConnIdleTime != &quot;&quot; {&#10;&#9;&#9;duration, _ := time.ParseDuration(cfg.MaxConnIdleTime)&#10;&#9;&#9;db.SetConnMaxIdleTime(duration)&#10;&#9;}&#10;&#10;&#9;// Validar conexión&#10;&#9;pingCtx, cancel := context.WithTimeout(ctx, time.Duration(cfg.ConnectTimeout)*time.Second)&#10;&#9;defer cancel()&#10;&#10;&#9;if err := db.PingContext(pingCtx); err != nil {&#10;&#9;&#9;db.Close()&#10;&#9;&#9;return nil, fmt.Errorf(&quot;db: no fue posible conectarse a SQL Server: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;logLabel := label&#10;&#9;if logLabel == &quot;&quot; {&#10;&#9;&#9;logLabel = &quot;SQL Server&quot;&#10;&#9;}&#10;&#10;&#9;log.Printf(&#10;&#9;&#9;&quot;✅ %s inicializado (host=%s:%d user=%s database=%s)&quot;,&#10;&#9;&#9;logLabel, cfg.Host, cfg.Port, cfg.User, visibleDatabase(cfg.Database),&#10;&#9;)&#10;&#10;&#9;return &amp;Manager{db: db}, nil&#10;}&#10;&#10;// GetDB devuelve el *sql.DB subyacente para quien necesite acceso directo.&#10;func GetDB(ctx context.Context) (*sql.DB, error) {&#10;&#9;mgr, err := GetManager(ctx)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return mgr.db, nil&#10;}&#10;&#10;func newManager(ctx context.Context) (*Manager, error) {&#10;&#9;// Cargamos variables de entorno (no es grave si falla; puede que ya se hayan cargado).&#10;&#9;if err := godotenv.Load(); err != nil {&#10;&#9;&#9;log.Println(&quot;db: no se ha encontrado archivo .env, usando únicamente variables de entorno del sistema&quot;)&#10;&#9;}&#10;&#10;&#9;cfg, err := loadConfig()&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;db, err := sql.Open(&quot;sqlserver&quot;, cfg.DSN)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;db: no fue posible crear el pool de conexiones: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;if cfg.MaxOpenConns &gt; 0 {&#10;&#9;&#9;db.SetMaxOpenConns(cfg.MaxOpenConns)&#10;&#9;}&#10;&#9;if cfg.MaxIdleConns &gt;= 0 {&#10;&#9;&#9;db.SetMaxIdleConns(cfg.MaxIdleConns)&#10;&#9;}&#10;&#9;if cfg.ConnMaxLifetime &gt; 0 {&#10;&#9;&#9;db.SetConnMaxLifetime(cfg.ConnMaxLifetime)&#10;&#9;}&#10;&#9;if cfg.ConnMaxIdleTime &gt; 0 {&#10;&#9;&#9;db.SetConnMaxIdleTime(cfg.ConnMaxIdleTime)&#10;&#9;}&#10;&#10;&#9;// Validar la conexión inmediatamente para fallar temprano si algo está mal.&#10;&#9;pingCtx, cancel := context.WithTimeout(ctx, 5*time.Second)&#10;&#9;defer cancel()&#10;&#9;if err := db.PingContext(pingCtx); err != nil {&#10;&#9;&#9;db.Close()&#10;&#9;&#9;return nil, fmt.Errorf(&quot;db: no fue posible conectarse a SQL Server: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;log.Printf(&#10;&#9;&#9;&quot;db: pool SQL Server inicializado (host=%s port=%s user=%s encrypt=%s database=%s)&quot;,&#10;&#9;&#9;cfg.Host, cfg.Port, cfg.User, cfg.Encrypt, visibleDatabase(cfg.Database),&#10;&#9;)&#10;&#10;&#9;return &amp;Manager{db: db}, nil&#10;}&#10;&#10;// Close cierra el pool de conexiones de manera segura; es idempotente.&#10;func (m *Manager) Close() {&#10;&#9;if m == nil {&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;m.closeOnce.Do(func() {&#10;&#9;&#9;m.db.Close()&#10;&#9;})&#10;}&#10;&#10;// DB devuelve el manejador subyacente *sql.DB.&#10;func (m *Manager) DB() *sql.DB {&#10;&#9;return m.db&#10;}&#10;&#10;type sqlServerConfig struct {&#10;&#9;DSN             string&#10;&#9;Host            string&#10;&#9;Port            string&#10;&#9;User            string&#10;&#9;Database        string&#10;&#9;Encrypt         string&#10;&#9;MaxOpenConns    int&#10;&#9;MaxIdleConns    int&#10;&#9;ConnMaxLifetime time.Duration&#10;&#9;ConnMaxIdleTime time.Duration&#10;}&#10;&#10;// Exec ejecuta una sentencia SQL (INSERT/UPDATE/DELETE) y devuelve el resultado.&#10;func (m *Manager) Exec(ctx context.Context, query string, args ...any) (sql.Result, error) {&#10;&#9;return m.db.ExecContext(ctx, query, args...)&#10;}&#10;&#10;// QueryContext ejecuta una consulta que devuelve filas, típicamente un SELECT.&#10;func (m *Manager) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {&#10;&#9;return m.db.QueryContext(ctx, query, args...)&#10;}&#10;&#10;// Query ejecuta una consulta que devuelve filas múltiples.&#10;func (m *Manager) Query(ctx context.Context, query string, args ...any) (*sql.Rows, error) {&#10;&#9;return m.db.QueryContext(ctx, query, args...)&#10;}&#10;&#10;// QueryRow ejecuta una consulta que espera exactamente una fila de resultado.&#10;func (m *Manager) QueryRow(ctx context.Context, query string, args ...any) *sql.Row {&#10;&#9;return m.db.QueryRowContext(ctx, query, args...)&#10;}&#10;&#10;func loadConfig() (*sqlServerConfig, error) {&#10;&#9;host := getEnv(&quot;GREENEX_SSMS_HOST&quot;, &quot;localhost&quot;)&#10;&#9;port := getEnv(&quot;GREENEX_SSMS_PORT&quot;, &quot;1433&quot;)&#10;&#9;user := getEnv(&quot;GREENEX_SSMS_DB_USER&quot;, &quot;sa&quot;)&#10;&#9;password := os.Getenv(&quot;GREENEX_SSMS_DB_PASSWORD&quot;)&#10;&#9;database := os.Getenv(&quot;GREENEX_SSMS_DB_NAME&quot;)&#10;&#9;encrypt := getEnv(&quot;GREENEX_SSMS_DB_ENCRYPT&quot;, &quot;disable&quot;)&#10;&#9;trustCert := getEnv(&quot;GREENEX_SSMS_DB_TRUST_CERT&quot;, &quot;true&quot;)&#10;&#9;appName := getEnv(&quot;GREENEX_SSMS_APP_NAME&quot;, &quot;API-Greenex&quot;)&#10;&#9;connectTimeout := getEnv(&quot;GREENEX_SSMS_CONNECT_TIMEOUT&quot;, &quot;15&quot;)&#10;&#10;&#9;query := url.Values{}&#10;&#9;query.Set(&quot;encrypt&quot;, encrypt)&#10;&#9;query.Set(&quot;TrustServerCertificate&quot;, trustCert)&#10;&#9;query.Set(&quot;app name&quot;, appName)&#10;&#9;if database != &quot;&quot; {&#10;&#9;&#9;query.Set(&quot;database&quot;, database)&#10;&#9;}&#10;&#9;if connectTimeout != &quot;&quot; {&#10;&#9;&#9;query.Set(&quot;connection timeout&quot;, connectTimeout)&#10;&#9;}&#10;&#10;&#9;u := &amp;url.URL{&#10;&#9;&#9;Scheme: &quot;sqlserver&quot;,&#10;&#9;&#9;Host:   fmt.Sprintf(&quot;%s:%s&quot;, host, port),&#10;&#9;}&#10;&#9;if password != &quot;&quot; {&#10;&#9;&#9;u.User = url.UserPassword(user, password)&#10;&#9;} else {&#10;&#9;&#9;u.User = url.User(user)&#10;&#9;}&#10;&#9;u.RawQuery = query.Encode()&#10;&#10;&#9;cfg := &amp;sqlServerConfig{&#10;&#9;&#9;DSN:             u.String(),&#10;&#9;&#9;Host:            host,&#10;&#9;&#9;Port:            port,&#10;&#9;&#9;User:            user,&#10;&#9;&#9;Database:        database,&#10;&#9;&#9;Encrypt:         encrypt,&#10;&#9;&#9;MaxOpenConns:    getIntEnv(&quot;DB_MAX_CONNS&quot;, 10),&#10;&#9;&#9;MaxIdleConns:    getIntEnv(&quot;DB_MIN_CONNS&quot;, 5),&#10;&#9;&#9;ConnMaxLifetime: getDurationEnv(&quot;DB_MAX_CONN_LIFETIME&quot;, &quot;30m&quot;),&#10;&#9;&#9;ConnMaxIdleTime: getDurationEnv(&quot;DB_MAX_CONN_IDLE_TIME&quot;, &quot;5m&quot;),&#10;&#9;}&#10;&#10;&#9;log.Printf(&#10;&#9;&#9;&quot;db: configuración -&gt; host=%s port=%s user=%s encrypt=%s database=%s&quot;,&#10;&#9;&#9;host, port, user, encrypt, visibleDatabase(database),&#10;&#9;)&#10;&#10;&#9;return cfg, nil&#10;}&#10;&#10;// GetSKUsFromView obtiene los SKUs desde la vista en SQL Server&#10;func (m *Manager) GetSKUsFromView(ctx context.Context, skuFormat string) ([]models.SKU, error) {&#10;&#9;// Implementación para obtener SKUs desde la vista&#10;&#9;return nil, fmt.Errorf(&quot;not implemented&quot;)&#10;}&#10;&#10;func visibleDatabase(name string) string {&#10;&#9;if name == &quot;&quot; {&#10;&#9;&#9;return &quot;&lt;predeterminada&gt;&quot;&#10;&#9;}&#10;&#9;return name&#10;}&#10;&#10;func getEnv(key, fallback string) string {&#10;&#9;if value := os.Getenv(key); value != &quot;&quot; {&#10;&#9;&#9;return value&#10;&#9;}&#10;&#9;return fallback&#10;}&#10;&#10;func getIntEnv(key string, fallback int) int {&#10;&#9;raw := os.Getenv(key)&#10;&#9;if raw == &quot;&quot; {&#10;&#9;&#9;return fallback&#10;&#9;}&#10;&#10;&#9;value, err := strconv.Atoi(raw)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Printf(&quot;db: valor inválido para %s='%s', usando %d&quot;, key, raw, fallback)&#10;&#9;&#9;return fallback&#10;&#9;}&#10;&#9;return value&#10;}&#10;&#10;func getDurationEnv(key, fallback string) time.Duration {&#10;&#9;raw := os.Getenv(key)&#10;&#9;if raw == &quot;&quot; {&#10;&#9;&#9;raw = fallback&#10;&#9;}&#10;&#10;&#9;value, err := time.ParseDuration(raw)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Printf(&quot;db: duración inválida para %s='%s', usando %s&quot;, key, raw, fallback)&#10;&#9;&#9;value, _ = time.ParseDuration(fallback)&#10;&#9;}&#10;&#9;return value&#10;}&#10;" />
              <option name="updatedContent" value="package db&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;database/sql&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;log&quot;&#10;&#9;&quot;net/url&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;strconv&quot;&#10;&#9;&quot;sync&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;api-dansort/internal/config&quot;&#10;&#9;&quot;api-dansort/internal/models&quot;&#10;&#10;&#9;&quot;github.com/joho/godotenv&quot;&#10;&#9;_ &quot;github.com/microsoft/go-mssqldb&quot;&#10;)&#10;&#10;// Manager encapsula un pool de conexiones a SQL Server y expone helpers seguros&#10;// para ejecutar consultas dentro del proyecto.&#10;type Manager struct {&#10;&#9;db        *sql.DB&#10;&#9;closeOnce sync.Once&#10;}&#10;&#10;var (&#10;&#9;managerOnce     sync.Once&#10;&#9;managerInstance *Manager&#10;&#9;managerErr      error&#10;)&#10;&#10;// GetManager devuelve una instancia singleton del gestor de base de datos.&#10;// La primera invocación crea el pool utilizando la configuración proveniente&#10;// de variables de entorno.&#10;func GetManager(ctx context.Context) (*Manager, error) {&#10;&#9;managerOnce.Do(func() {&#10;&#9;&#9;var mgr *Manager&#10;&#9;&#9;mgr, managerErr = newManager(ctx)&#10;&#9;&#9;if managerErr == nil {&#10;&#9;&#9;&#9;managerInstance = mgr&#10;&#9;&#9;}&#10;&#9;})&#10;&#10;&#9;if managerErr != nil {&#10;&#9;&#9;return nil, managerErr&#10;&#9;}&#10;&#9;return managerInstance, nil&#10;}&#10;&#10;// GetManagerWithConfig devuelve una instancia del gestor usando configuración YAML&#10;// No usa singleton, crea una nueva instancia cada vez&#10;func GetManagerWithConfig(ctx context.Context, cfg config.SQLServerConfig) (*Manager, error) {&#10;&#9;return newManagerWithConfig(ctx, cfg, &quot;&quot;)&#10;}&#10;&#10;// GetManagerWithConfigAndLabel crea un manager con label personalizada para logs&#10;func GetManagerWithConfigAndLabel(ctx context.Context, cfg config.SQLServerConfig, label string) (*Manager, error) {&#10;&#9;return newManagerWithConfig(ctx, cfg, label)&#10;}&#10;&#10;// newManagerWithConfig es la función interna que crea el manager&#10;func newManagerWithConfig(ctx context.Context, cfg config.SQLServerConfig, label string) (*Manager, error) {&#10;&#9;// Construir URL con encoding apropiado para caracteres especiales&#10;&#9;query := url.Values{}&#10;&#9;if cfg.Database != &quot;&quot; {&#10;&#9;&#9;query.Add(&quot;database&quot;, cfg.Database)&#10;&#9;}&#10;&#9;query.Add(&quot;encrypt&quot;, cfg.Encrypt)&#10;&#9;query.Add(&quot;TrustServerCertificate&quot;, fmt.Sprintf(&quot;%t&quot;, cfg.TrustCert))&#10;&#10;&#9;appName := cfg.AppName&#10;&#9;if label != &quot;&quot; {&#10;&#9;&#9;appName = fmt.Sprintf(&quot;%s-%s&quot;, cfg.AppName, label)&#10;&#9;}&#10;&#9;query.Add(&quot;app name&quot;, appName)&#10;&#9;query.Add(&quot;connection timeout&quot;, fmt.Sprintf(&quot;%d&quot;, cfg.ConnectTimeout))&#10;&#10;&#9;u := &amp;url.URL{&#10;&#9;&#9;Scheme:   &quot;sqlserver&quot;,&#10;&#9;&#9;User:     url.UserPassword(cfg.User, cfg.Password),&#10;&#9;&#9;Host:     fmt.Sprintf(&quot;%s:%d&quot;, cfg.Host, cfg.Port),&#10;&#9;&#9;RawQuery: query.Encode(),&#10;&#9;}&#10;&#10;&#9;connString := u.String()&#10;&#10;&#9;db, err := sql.Open(&quot;sqlserver&quot;, connString)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;db: no fue posible crear el pool de conexiones: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;// Configurar pool&#10;&#9;db.SetMaxOpenConns(cfg.MaxConns)&#10;&#9;db.SetMaxIdleConns(cfg.MinConns)&#10;&#10;&#9;if cfg.MaxConnLifetime != &quot;&quot; {&#10;&#9;&#9;duration, _ := time.ParseDuration(cfg.MaxConnLifetime)&#10;&#9;&#9;db.SetConnMaxLifetime(duration)&#10;&#9;}&#10;&#9;if cfg.MaxConnIdleTime != &quot;&quot; {&#10;&#9;&#9;duration, _ := time.ParseDuration(cfg.MaxConnIdleTime)&#10;&#9;&#9;db.SetConnMaxIdleTime(duration)&#10;&#9;}&#10;&#10;&#9;// Validar conexión&#10;&#9;pingCtx, cancel := context.WithTimeout(ctx, time.Duration(cfg.ConnectTimeout)*time.Second)&#10;&#9;defer cancel()&#10;&#10;&#9;if err := db.PingContext(pingCtx); err != nil {&#10;&#9;&#9;db.Close()&#10;&#9;&#9;return nil, fmt.Errorf(&quot;db: no fue posible conectarse a SQL Server: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;logLabel := label&#10;&#9;if logLabel == &quot;&quot; {&#10;&#9;&#9;logLabel = &quot;SQL Server&quot;&#10;&#9;}&#10;&#10;&#9;log.Printf(&#10;&#9;&#9;&quot;✅ %s inicializado (host=%s:%d user=%s database=%s)&quot;,&#10;&#9;&#9;logLabel, cfg.Host, cfg.Port, cfg.User, visibleDatabase(cfg.Database),&#10;&#9;)&#10;&#10;&#9;return &amp;Manager{db: db}, nil&#10;}&#10;&#10;// GetDB devuelve el *sql.DB subyacente para quien necesite acceso directo.&#10;func GetDB(ctx context.Context) (*sql.DB, error) {&#10;&#9;mgr, err := GetManager(ctx)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return mgr.db, nil&#10;}&#10;&#10;func newManager(ctx context.Context) (*Manager, error) {&#10;&#9;// Cargamos variables de entorno (no es grave si falla; puede que ya se hayan cargado).&#10;&#9;if err := godotenv.Load(); err != nil {&#10;&#9;&#9;log.Println(&quot;db: no se ha encontrado archivo .env, usando únicamente variables de entorno del sistema&quot;)&#10;&#9;}&#10;&#10;&#9;cfg, err := loadConfig()&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;db, err := sql.Open(&quot;sqlserver&quot;, cfg.DSN)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;db: no fue posible crear el pool de conexiones: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;if cfg.MaxOpenConns &gt; 0 {&#10;&#9;&#9;db.SetMaxOpenConns(cfg.MaxOpenConns)&#10;&#9;}&#10;&#9;if cfg.MaxIdleConns &gt;= 0 {&#10;&#9;&#9;db.SetMaxIdleConns(cfg.MaxIdleConns)&#10;&#9;}&#10;&#9;if cfg.ConnMaxLifetime &gt; 0 {&#10;&#9;&#9;db.SetConnMaxLifetime(cfg.ConnMaxLifetime)&#10;&#9;}&#10;&#9;if cfg.ConnMaxIdleTime &gt; 0 {&#10;&#9;&#9;db.SetConnMaxIdleTime(cfg.ConnMaxIdleTime)&#10;&#9;}&#10;&#10;&#9;// Validar la conexión inmediatamente para fallar temprano si algo está mal.&#10;&#9;pingCtx, cancel := context.WithTimeout(ctx, 5*time.Second)&#10;&#9;defer cancel()&#10;&#9;if err := db.PingContext(pingCtx); err != nil {&#10;&#9;&#9;db.Close()&#10;&#9;&#9;return nil, fmt.Errorf(&quot;db: no fue posible conectarse a SQL Server: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;log.Printf(&#10;&#9;&#9;&quot;db: pool SQL Server inicializado (host=%s port=%s user=%s encrypt=%s database=%s)&quot;,&#10;&#9;&#9;cfg.Host, cfg.Port, cfg.User, cfg.Encrypt, visibleDatabase(cfg.Database),&#10;&#9;)&#10;&#10;&#9;return &amp;Manager{db: db}, nil&#10;}&#10;&#10;// Close cierra el pool de conexiones de manera segura; es idempotente.&#10;func (m *Manager) Close() {&#10;&#9;if m == nil {&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;m.closeOnce.Do(func() {&#10;&#9;&#9;m.db.Close()&#10;&#9;})&#10;}&#10;&#10;// DB devuelve el manejador subyacente *sql.DB.&#10;func (m *Manager) DB() *sql.DB {&#10;&#9;return m.db&#10;}&#10;&#10;type sqlServerConfig struct {&#10;&#9;DSN             string&#10;&#9;Host            string&#10;&#9;Port            string&#10;&#9;User            string&#10;&#9;Database        string&#10;&#9;Encrypt         string&#10;&#9;MaxOpenConns    int&#10;&#9;MaxIdleConns    int&#10;&#9;ConnMaxLifetime time.Duration&#10;&#9;ConnMaxIdleTime time.Duration&#10;}&#10;&#10;// Exec ejecuta una sentencia SQL (INSERT/UPDATE/DELETE) y devuelve el resultado.&#10;func (m *Manager) Exec(ctx context.Context, query string, args ...any) (sql.Result, error) {&#10;&#9;return m.db.ExecContext(ctx, query, args...)&#10;}&#10;&#10;// QueryContext ejecuta una consulta que devuelve filas, típicamente un SELECT.&#10;func (m *Manager) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {&#10;&#9;return m.db.QueryContext(ctx, query, args...)&#10;}&#10;&#10;// Query ejecuta una consulta que devuelve filas múltiples.&#10;func (m *Manager) Query(ctx context.Context, query string, args ...any) (*sql.Rows, error) {&#10;&#9;return m.db.QueryContext(ctx, query, args...)&#10;}&#10;&#10;// QueryRow ejecuta una consulta que espera exactamente una fila de resultado.&#10;func (m *Manager) QueryRow(ctx context.Context, query string, args ...any) *sql.Row {&#10;&#9;return m.db.QueryRowContext(ctx, query, args...)&#10;}&#10;&#10;func loadConfig() (*sqlServerConfig, error) {&#10;&#9;host := getEnv(&quot;GREENEX_SSMS_HOST&quot;, &quot;localhost&quot;)&#10;&#9;port := getEnv(&quot;GREENEX_SSMS_PORT&quot;, &quot;1433&quot;)&#10;&#9;user := getEnv(&quot;GREENEX_SSMS_DB_USER&quot;, &quot;sa&quot;)&#10;&#9;password := os.Getenv(&quot;GREENEX_SSMS_DB_PASSWORD&quot;)&#10;&#9;database := os.Getenv(&quot;GREENEX_SSMS_DB_NAME&quot;)&#10;&#9;encrypt := getEnv(&quot;GREENEX_SSMS_DB_ENCRYPT&quot;, &quot;disable&quot;)&#10;&#9;trustCert := getEnv(&quot;GREENEX_SSMS_DB_TRUST_CERT&quot;, &quot;true&quot;)&#10;&#9;appName := getEnv(&quot;GREENEX_SSMS_APP_NAME&quot;, &quot;API-Greenex&quot;)&#10;&#9;connectTimeout := getEnv(&quot;GREENEX_SSMS_CONNECT_TIMEOUT&quot;, &quot;15&quot;)&#10;&#10;&#9;query := url.Values{}&#10;&#9;query.Set(&quot;encrypt&quot;, encrypt)&#10;&#9;query.Set(&quot;TrustServerCertificate&quot;, trustCert)&#10;&#9;query.Set(&quot;app name&quot;, appName)&#10;&#9;if database != &quot;&quot; {&#10;&#9;&#9;query.Set(&quot;database&quot;, database)&#10;&#9;}&#10;&#9;if connectTimeout != &quot;&quot; {&#10;&#9;&#9;query.Set(&quot;connection timeout&quot;, connectTimeout)&#10;&#9;}&#10;&#10;&#9;u := &amp;url.URL{&#10;&#9;&#9;Scheme: &quot;sqlserver&quot;,&#10;&#9;&#9;Host:   fmt.Sprintf(&quot;%s:%s&quot;, host, port),&#10;&#9;}&#10;&#9;if password != &quot;&quot; {&#10;&#9;&#9;u.User = url.UserPassword(user, password)&#10;&#9;} else {&#10;&#9;&#9;u.User = url.User(user)&#10;&#9;}&#10;&#9;u.RawQuery = query.Encode()&#10;&#10;&#9;cfg := &amp;sqlServerConfig{&#10;&#9;&#9;DSN:             u.String(),&#10;&#9;&#9;Host:            host,&#10;&#9;&#9;Port:            port,&#10;&#9;&#9;User:            user,&#10;&#9;&#9;Database:        database,&#10;&#9;&#9;Encrypt:         encrypt,&#10;&#9;&#9;MaxOpenConns:    getIntEnv(&quot;DB_MAX_CONNS&quot;, 10),&#10;&#9;&#9;MaxIdleConns:    getIntEnv(&quot;DB_MIN_CONNS&quot;, 5),&#10;&#9;&#9;ConnMaxLifetime: getDurationEnv(&quot;DB_MAX_CONN_LIFETIME&quot;, &quot;30m&quot;),&#10;&#9;&#9;ConnMaxIdleTime: getDurationEnv(&quot;DB_MAX_CONN_IDLE_TIME&quot;, &quot;5m&quot;),&#10;&#9;}&#10;&#10;&#9;log.Printf(&#10;&#9;&#9;&quot;db: configuración -&gt; host=%s port=%s user=%s encrypt=%s database=%s&quot;,&#10;&#9;&#9;host, port, user, encrypt, visibleDatabase(database),&#10;&#9;)&#10;&#10;&#9;return cfg, nil&#10;}&#10;&#10;// GetSKUsFromView obtiene los SKUs desde la vista de UNITEC DB.&#10;func (m *Manager) GetSKUsFromView(ctx context.Context) ([]models.SKU, error) {&#10;&#9;rows, err := m.db.QueryContext(ctx, SELECT_UNITEC_DB_DBO_SEGREGAZIONE_PROGRAMMA)&#10;&#9;if err != nil {&#10;&#9;&#9;// Fallback a la query sin VIE_Dark&#10;&#9;&#9;log.Printf(&quot;⚠️  Error con la query principal de SKUs, intentando fallback: %v&quot;, err)&#10;&#9;&#9;rows, err = m.db.QueryContext(ctx, SELECT_UNITEC_DB_DBO_SEGREGAZIONE_PROGRAMMA_FALLBACK)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;error al consultar SKUs desde UNITEC (incluso con fallback): %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;defer rows.Close()&#10;&#10;&#9;var skus []models.SKU&#10;&#9;for rows.Next() {&#10;&#9;&#9;var sku models.SKU&#10;&#9;&#9;var nombreVariedad sql.NullString&#10;&#9;&#9;if err := rows.Scan(&amp;sku.Calibre, &amp;sku.Variedad, &amp;sku.Embalaje, &amp;sku.Dark, &amp;nombreVariedad, &amp;sku.Linea); err != nil {&#10;&#9;&#9;&#9;log.Printf(&quot;⚠️  Error al escanear fila de SKU: %v&quot;, err)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#9;&#9;sku.Estado = true // Marcar como activo por defecto&#10;&#9;&#9;skus = append(skus, sku)&#10;&#9;}&#10;&#10;&#9;if err := rows.Err(); err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;error durante la iteración de filas de SKU: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;log.Printf(&quot;✅ %d SKUs obtenidos desde UNITEC&quot;, len(skus))&#10;&#9;return skus, nil&#10;}&#10;&#10;func visibleDatabase(name string) string {&#10;&#9;if name == &quot;&quot; {&#10;&#9;&#9;return &quot;&lt;predeterminada&gt;&quot;&#10;&#9;}&#10;&#9;return name&#10;}&#10;&#10;func getEnv(key, fallback string) string {&#10;&#9;if value := os.Getenv(key); value != &quot;&quot; {&#10;&#9;&#9;return value&#10;&#9;}&#10;&#9;return fallback&#10;}&#10;&#10;func getIntEnv(key string, fallback int) int {&#10;&#9;raw := os.Getenv(key)&#10;&#9;if raw == &quot;&quot; {&#10;&#9;&#9;return fallback&#10;&#9;}&#10;&#10;&#9;value, err := strconv.Atoi(raw)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Printf(&quot;db: valor inválido para %s='%s', usando %d&quot;, key, raw, fallback)&#10;&#9;&#9;return fallback&#10;&#9;}&#10;&#9;return value&#10;}&#10;&#10;func getDurationEnv(key, fallback string) time.Duration {&#10;&#9;raw := os.Getenv(key)&#10;&#9;if raw == &quot;&quot; {&#10;&#9;&#9;raw = fallback&#10;&#9;}&#10;&#10;&#9;value, err := time.ParseDuration(raw)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Printf(&quot;db: duración inválida para %s='%s', usando %s&quot;, key, raw, fallback)&#10;&#9;&#9;value, _ = time.ParseDuration(fallback)&#10;&#9;}&#10;&#9;return value&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/flow/sku_sync_worker.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/flow/sku_sync_worker.go" />
              <option name="originalContent" value="package flow&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;log&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;api-dansort/internal/db&quot;&#10;&#9;&quot;api-dansort/internal/listeners&quot;&#10;&#9;&quot;api-dansort/internal/models&quot;&#10;&#9;&quot;api-dansort/internal/shared&quot;&#10;)&#10;&#10;// SKUSyncWorker sincroniza periódicamente SKUs desde SQL Server a PostgreSQL&#10;// y propaga cambios a todos los sorters&#10;type SKUSyncWorker struct {&#10;&#9;ctx          context.Context&#10;&#9;cancel       context.CancelFunc&#10;&#9;sqlServerMgr *db.Manager         // SQL Server (vista)&#10;&#9;postgresMgr  *db.PostgresManager // PostgreSQL (tabla sku)&#10;&#9;skuManager   *SKUManager&#10;&#9;sorters      []shared.SorterInterface // Lista de sorters a notificar&#10;&#9;interval     time.Duration&#10;&#9;wsHub        *listeners.WebSocketHub&#10;}&#10;&#10;// NewSKUSyncWorker crea una nueva instancia del worker de sincronización&#10;func NewSKUSyncWorker(&#10;&#9;ctx context.Context,&#10;&#9;sqlServerMgr *db.Manager,&#10;&#9;postgresMgr *db.PostgresManager,&#10;&#9;skuManager *SKUManager,&#10;&#9;sorters []shared.SorterInterface,&#10;&#9;interval time.Duration,&#10;&#9;wsHub interface{},&#10;) *SKUSyncWorker {&#10;&#9;workerCtx, cancel := context.WithCancel(ctx)&#10;&#10;&#9;var hub *listeners.WebSocketHub&#10;&#9;if h, ok := wsHub.(*listeners.WebSocketHub); ok {&#10;&#9;&#9;hub = h&#10;&#9;}&#10;&#10;&#9;return &amp;SKUSyncWorker{&#10;&#9;&#9;ctx:          workerCtx,&#10;&#9;&#9;cancel:       cancel,&#10;&#9;&#9;sqlServerMgr: sqlServerMgr,&#10;&#9;&#9;postgresMgr:  postgresMgr,&#10;&#9;&#9;skuManager:   skuManager,&#10;&#9;&#9;sorters:      sorters,&#10;&#9;&#9;interval:     interval,&#10;&#9;&#9;wsHub:        hub,&#10;&#9;}&#10;}&#10;&#10;// Start inicia el worker de sincronización&#10;func (w *SKUSyncWorker) Start() {&#10;&#9;go w.run()&#10;&#9;log.Printf(&quot; SKU Sync Worker iniciado (intervalo: %v)&quot;, w.interval)&#10;}&#10;&#10;// Stop detiene el worker de sincronización&#10;func (w *SKUSyncWorker) Stop() {&#10;&#9;w.cancel()&#10;&#9;log.Println(&quot; SKU Sync Worker detenido&quot;)&#10;}&#10;&#10;func (w *SKUSyncWorker) run() {&#10;&#9;// CRÍTICO: Capturar panics para debug&#10;&#9;defer func() {&#10;&#9;&#9;if r := recover(); r != nil {&#10;&#9;&#9;&#9;log.Printf(&quot;❌ PANIC en SKU Sync Worker: %v&quot;, r)&#10;&#9;&#9;}&#10;&#9;}()&#10;&#10;&#9;ticker := time.NewTicker(w.interval)&#10;&#9;defer ticker.Stop()&#10;&#10;&#9;log.Println(&quot; [Worker] Goroutine iniciada&quot;)&#10;&#10;&#9;// NOTA: NO recargamos desde PostgreSQL aquí porque:&#10;&#9;// 1. Ya se hizo en main.go antes de crear el worker&#10;&#9;// 2. El primer syncSKUs() inmediatamente recargará desde UNITEC (fuente de verdad)&#10;&#9;// 3. Evitamos race condition / deadlock por doble lectura concurrente&#10;&#9;log.Println(&quot;⏭️  [Worker] Omitiendo carga inicial (ya hecha en main.go)&quot;)&#10;&#10;&#9;// Ejecutar sync desde UNITEC inmediatamente después (actualiza desde fuente de verdad)&#10;&#9;log.Println(&quot; [Worker] Ejecutando primer syncSKUs()...&quot;)&#10;&#9;w.syncSKUs()&#10;&#9;log.Println(&quot;✅ [Worker] Primer syncSKUs() completado&quot;)&#10;&#10;&#9;log.Println(&quot; [Worker] Entrando al loop principal...&quot;)&#10;&#9;for {&#10;&#9;&#9;select {&#10;&#9;&#9;case &lt;-w.ctx.Done():&#10;&#9;&#9;&#9;log.Println(&quot; [Worker] Contexto cancelado, saliendo...&quot;)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;case &lt;-ticker.C:&#10;&#9;&#9;&#9;log.Println(&quot;⏰ [Worker] Ticker disparado, ejecutando syncSKUs()...&quot;)&#10;&#9;&#9;&#9;w.syncSKUs()&#10;&#9;&#9;&#9;log.Println(&quot;✅ [Worker] syncSKUs() periódico completado&quot;)&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;&#10;func (w *SKUSyncWorker) syncSKUs() {&#10;&#9;startTime := time.Now()&#10;&#9;ctx, cancel := context.WithTimeout(w.ctx, 30*time.Second)&#10;&#9;defer cancel()&#10;&#10;&#9;log.Println(&quot; Iniciando sincronización de SKUs desde UNITEC...&quot;)&#10;&#10;&#9;// 1. Obtener SKUs desde SQL Server (fuente de verdad)&#10;&#9;skusFromSQLServer, err := w.sqlServerMgr.GetSKUsFromView(ctx)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Printf(&quot;❌ Error al obtener SKUs desde SQL Server: %v&quot;, err)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;log.Printf(&quot;   → %d SKUs obtenidos desde SQL Server&quot;, len(skusFromSQLServer))&#10;&#10;&#9;// 2. Sincronizar con PostgreSQL (insertar/actualizar)&#10;&#9;inserted, updated, err := w.postgresMgr.SyncSKUs(ctx, skusFromSQLServer)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Printf(&quot;❌ Error al sincronizar SKUs con PostgreSQL: %v&quot;, err)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;log.Printf(&quot;   → %d SKUs insertados, %d actualizados en PostgreSQL&quot;, inserted, updated)&#10;&#10;&#9;// 3. Recargar todos los SKUs desde PostgreSQL (ahora que está actualizado)&#10;&#9;if err := w.skuManager.ReloadFromDB(ctx); err != nil {&#10;&#9;&#9;log.Printf(&quot;❌ Error al recargar SKUs desde PostgreSQL: %v&quot;, err)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;log.Println(&quot;✅ SKUs recargados desde PostgreSQL&quot;)&#10;&#10;&#9;// 4. Propagar a todos los sorters&#10;&#9;activeSKUs := w.skuManager.GetActiveSKUs()&#10;&#9;assignableSKUs := []models.SKUAssignable{models.GetRejectSKU()} // Agregar REJECT al inicio&#10;&#10;&#9;for _, sku := range activeSKUs {&#10;&#9;&#9;assignableSKUs = append(assignableSKUs, sku.ToAssignableWithHash())&#10;&#9;}&#10;&#10;&#9;log.Printf(&quot; Sync SKU: Propagando %d SKUs (REJECT + %d activos) a sorters...&quot;, len(assignableSKUs), len(activeSKUs))&#10;&#10;&#9;// Notificar a los sorters para que actualicen sus listas internas&#10;&#9;for _, sorter := range w.sorters {&#10;&#9;&#9;sorter.UpdateSKUs(assignableSKUs)&#10;&#9;}&#10;&#10;&#9;// Forzar notificación al WebSocket&#10;&#9;if hub, ok := w.wsHub.(*listeners.WebSocketHub); ok {&#10;&#9;&#9;for _, sorter := range w.sorters {&#10;&#9;&#9;&#9;hub.NotifySKUAssigned(sorter)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;log.Printf(&quot;✅ Sincronización de SKUs completada en %v&quot;, time.Since(startTime))&#10;}&#10;" />
              <option name="updatedContent" value="package flow&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;log&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;api-dansort/internal/db&quot;&#10;&#9;&quot;api-dansort/internal/listeners&quot;&#10;&#9;&quot;api-dansort/internal/models&quot;&#10;&#9;&quot;api-dansort/internal/shared&quot;&#10;)&#10;&#10;// SKUSyncWorker sincroniza periódicamente SKUs desde SQL Server a PostgreSQL&#10;// y propaga cambios a todos los sorters&#10;type SKUSyncWorker struct {&#10;&#9;ctx          context.Context&#10;&#9;cancel       context.CancelFunc&#10;&#9;sqlServerMgr *db.Manager         // SQL Server (vista)&#10;&#9;postgresMgr  *db.PostgresManager // PostgreSQL (tabla sku)&#10;&#9;skuManager   *SKUManager&#10;&#9;sorters      []shared.SorterInterface // Lista de sorters a notificar&#10;&#9;interval     time.Duration&#10;&#9;wsHub        *listeners.WebSocketHub&#10;}&#10;&#10;// NewSKUSyncWorker crea una nueva instancia del worker de sincronización&#10;func NewSKUSyncWorker(&#10;&#9;ctx context.Context,&#10;&#9;sqlServerMgr *db.Manager,&#10;&#9;postgresMgr *db.PostgresManager,&#10;&#9;skuManager *SKUManager,&#10;&#9;sorters []shared.SorterInterface,&#10;&#9;interval time.Duration,&#10;&#9;wsHub interface{},&#10;) *SKUSyncWorker {&#10;&#9;workerCtx, cancel := context.WithCancel(ctx)&#10;&#10;&#9;var hub *listeners.WebSocketHub&#10;&#9;if h, ok := wsHub.(*listeners.WebSocketHub); ok {&#10;&#9;&#9;hub = h&#10;&#9;}&#10;&#10;&#9;return &amp;SKUSyncWorker{&#10;&#9;&#9;ctx:          workerCtx,&#10;&#9;&#9;cancel:       cancel,&#10;&#9;&#9;sqlServerMgr: sqlServerMgr,&#10;&#9;&#9;postgresMgr:  postgresMgr,&#10;&#9;&#9;skuManager:   skuManager,&#10;&#9;&#9;sorters:      sorters,&#10;&#9;&#9;interval:     interval,&#10;&#9;&#9;wsHub:        hub,&#10;&#9;}&#10;}&#10;&#10;// Start inicia el worker de sincronización&#10;func (w *SKUSyncWorker) Start() {&#10;&#9;go w.run()&#10;&#9;log.Printf(&quot; SKU Sync Worker iniciado (intervalo: %v)&quot;, w.interval)&#10;}&#10;&#10;// Stop detiene el worker de sincronización&#10;func (w *SKUSyncWorker) Stop() {&#10;&#9;w.cancel()&#10;&#9;log.Println(&quot; SKU Sync Worker detenido&quot;)&#10;}&#10;&#10;func (w *SKUSyncWorker) run() {&#10;&#9;// CRÍTICO: Capturar panics para debug&#10;&#9;defer func() {&#10;&#9;&#9;if r := recover(); r != nil {&#10;&#9;&#9;&#9;log.Printf(&quot;❌ PANIC en SKU Sync Worker: %v&quot;, r)&#10;&#9;&#9;}&#10;&#9;}()&#10;&#10;&#9;ticker := time.NewTicker(w.interval)&#10;&#9;defer ticker.Stop()&#10;&#10;&#9;log.Println(&quot; [Worker] Goroutine iniciada&quot;)&#10;&#10;&#9;// NOTA: NO recargamos desde PostgreSQL aquí porque:&#10;&#9;// 1. Ya se hizo en main.go antes de crear el worker&#10;&#9;// 2. El primer syncSKUs() inmediatamente recargará desde UNITEC (fuente de verdad)&#10;&#9;// 3. Evitamos race condition / deadlock por doble lectura concurrente&#10;&#9;log.Println(&quot;⏭️  [Worker] Omitiendo carga inicial (ya hecha en main.go)&quot;)&#10;&#10;&#9;// Ejecutar sync desde UNITEC inmediatamente después (actualiza desde fuente de verdad)&#10;&#9;log.Println(&quot; [Worker] Ejecutando primer syncSKUs()...&quot;)&#10;&#9;w.syncSKUs()&#10;&#9;log.Println(&quot;✅ [Worker] Primer syncSKUs() completado&quot;)&#10;&#10;&#9;log.Println(&quot; [Worker] Entrando al loop principal...&quot;)&#10;&#9;for {&#10;&#9;&#9;select {&#10;&#9;&#9;case &lt;-w.ctx.Done():&#10;&#9;&#9;&#9;log.Println(&quot; [Worker] Contexto cancelado, saliendo...&quot;)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;case &lt;-ticker.C:&#10;&#9;&#9;&#9;log.Println(&quot;⏰ [Worker] Ticker disparado, ejecutando syncSKUs()...&quot;)&#10;&#9;&#9;&#9;w.syncSKUs()&#10;&#9;&#9;&#9;log.Println(&quot;✅ [Worker] syncSKUs() periódico completado&quot;)&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;&#10;func (w *SKUSyncWorker) syncSKUs() {&#10;&#9;startTime := time.Now()&#10;&#9;ctx, cancel := context.WithTimeout(w.ctx, 30*time.Second)&#10;&#9;defer cancel()&#10;&#10;&#9;log.Println(&quot; Iniciando sincronización de SKUs desde UNITEC...&quot;)&#10;&#10;&#9;// 1. Obtener SKUs desde SQL Server (fuente de verdad)&#10;&#9;skusFromSQLServer, err := w.sqlServerMgr.GetSKUsFromView(ctx)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Printf(&quot;❌ Error al obtener SKUs desde SQL Server: %v&quot;, err)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;log.Printf(&quot;   → %d SKUs obtenidos desde SQL Server&quot;, len(skusFromSQLServer))&#10;&#10;&#9;// 2. Sincronizar con PostgreSQL (insertar/actualizar)&#10;&#9;inserted, updated, err := w.postgresMgr.SyncSKUs(ctx, skusFromSQLServer)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Printf(&quot;❌ Error al sincronizar SKUs con PostgreSQL: %v&quot;, err)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;log.Printf(&quot;   → %d SKUs insertados, %d actualizados en PostgreSQL&quot;, inserted, updated)&#10;&#10;&#9;// 3. Recargar todos los SKUs desde PostgreSQL (ahora que está actualizado)&#10;&#9;if err := w.skuManager.ReloadFromDB(ctx); err != nil {&#10;&#9;&#9;log.Printf(&quot;❌ Error al recargar SKUs desde PostgreSQL: %v&quot;, err)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;log.Println(&quot;✅ SKUs recargados desde PostgreSQL&quot;)&#10;&#10;&#9;// 4. Propagar a todos los sorters&#10;&#9;activeSKUs := w.skuManager.GetActiveSKUs()&#10;&#9;assignableSKUs := []models.SKUAssignable{models.GetRejectSKU()} // Agregar REJECT al inicio&#10;&#10;&#9;for _, sku := range activeSKUs {&#10;&#9;&#9;assignableSKUs = append(assignableSKUs, sku.ToAssignableWithHash())&#10;&#9;}&#10;&#10;&#9;log.Printf(&quot; Sync SKU: Propagando %d SKUs (REJECT + %d activos) a sorters...&quot;, len(assignableSKUs), len(activeSKUs))&#10;&#10;&#9;// Notificar a los sorters para que actualicen sus listas internas&#10;&#9;for _, sorter := range w.sorters {&#10;&#9;&#9;sorter.UpdateSKUs(assignableSKUs)&#10;&#9;}&#10;&#10;&#9;// Forzar notificación al WebSocket&#10;&#9;if w.wsHub != nil {&#10;&#9;&#9;for _, sorter := range w.sorters {&#10;&#9;&#9;&#9;w.wsHub.NotifySKUAssigned(sorter)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;log.Printf(&quot;✅ Sincronización de SKUs completada en %v&quot;, time.Since(startTime))&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>