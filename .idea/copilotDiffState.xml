<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/internal/flow/box_cache_manager.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/flow/box_cache_manager.go" />
              <option name="originalContent" value="package flow&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;log&quot;&#10;&#9;&quot;sync&quot;&#10;&#9;&quot;sync/atomic&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;API-DANSORT/internal/db&quot;&#10;)&#10;&#10;// BoxData representa los datos de una caja cacheados en memoria&#10;type BoxData struct {&#10;&#9;CodCaja  string&#10;&#9;Especie  string&#10;&#9;Calibre  string&#10;&#9;Variedad string&#10;&#9;Embalaje string&#10;&#9;Dark     int&#10;}&#10;&#10;// BoxCacheManager gestiona un caché en memoria de las últimas N cajas&#10;// del proceso actual, con acceso directo O(1) por código de caja&#10;type BoxCacheManager struct {&#10;&#9;ctx         context.Context&#10;&#9;cancel      context.CancelFunc&#10;&#9;ssmsManager *db.Manager&#10;&#10;&#9;// Caché indexado por codCaja para acceso O(1) directo&#10;&#9;boxes map[string]BoxData&#10;&#9;mu    sync.RWMutex&#10;&#10;&#9;// Configuración&#10;&#9;cacheSize  int           // Número de cajas a cachear (ej: 1000)&#10;&#9;interval   time.Duration // Intervalo de polling (ej: 2s)&#10;&#9;started    atomic.Bool   // Flag para evitar múltiples Start()&#10;&#9;refreshing atomic.Bool   // Flag para evitar refreshes simultáneos&#10;&#10;&#9;// Métricas&#10;&#9;hits   atomic.Int64 // Búsquedas exitosas en caché&#10;&#9;misses atomic.Int64 // Búsquedas fallidas (fallback a DB)&#10;&#10;&#9;// Observabilidad de tiempos&#10;&#9;lastRefreshDuration time.Duration // Tiempo del último refresh completo&#10;&#9;lastRefreshTime     time.Time     // Timestamp del último refresh&#10;&#9;mu2                 sync.RWMutex  // Mutex para métricas de tiempo&#10;}&#10;&#10;// NewBoxCacheManager crea una nueva instancia del gestor de caché de cajas&#10;func NewBoxCacheManager(ctx context.Context, ssmsManager *db.Manager, cacheSize int, interval time.Duration) *BoxCacheManager {&#10;&#9;workerCtx, cancel := context.WithCancel(ctx)&#10;&#10;&#9;if cacheSize &lt;= 0 {&#10;&#9;&#9;cacheSize = 500 // Default&#10;&#9;&#9;log.Printf(&quot;⚠️  [BoxCache] Tamaño de caché inválido, usando default: %d&quot;, cacheSize)&#10;&#9;}&#10;&#10;&#9;if interval &lt;= 0 {&#10;&#9;&#9;interval = 5 * time.Second // Default&#10;&#9;&#9;log.Printf(&quot;⚠️  [BoxCache] Intervalo inválido, usando default: %v&quot;, interval)&#10;&#9;}&#10;&#10;&#9;return &amp;BoxCacheManager{&#10;&#9;&#9;ctx:         workerCtx,&#10;&#9;&#9;cancel:      cancel,&#10;&#9;&#9;ssmsManager: ssmsManager,&#10;&#9;&#9;boxes:       make(map[string]BoxData, cacheSize),&#10;&#9;&#9;cacheSize:   cacheSize,&#10;&#9;&#9;interval:    interval,&#10;&#9;}&#10;}&#10;&#10;// Start inicia el worker de sincronización periódica&#10;func (m *BoxCacheManager) Start() {&#10;&#9;// Protección contra múltiples Start()&#10;&#9;if !m.started.CompareAndSwap(false, true) {&#10;&#9;&#9;log.Printf(&quot;⚠️  [BoxCache] Start() ya fue llamado, ignorando llamada duplicada&quot;)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;log.Printf(&quot; [BoxCache] Iniciando con configuración:&quot;)&#10;&#9;log.Printf(&quot;    Tamaño de caché: %d cajas (acceso O(1) directo por ID)&quot;, m.cacheSize)&#10;&#9;log.Printf(&quot;   ⏱️  Intervalo de polling: %v&quot;, m.interval)&#10;&#9;log.Printf(&quot;    Primera carga inmediata...&quot;)&#10;&#10;&#9;// Primera carga inmediata (bloqueante)&#10;&#9;if err := m.refresh(); err != nil {&#10;&#9;&#9;log.Printf(&quot;❌ [BoxCache] Error en carga inicial: %v&quot;, err)&#10;&#9;&#9;log.Printf(&quot;   ⚠️  El caché estará vacío hasta el próximo refresh exitoso&quot;)&#10;&#9;}&#10;&#10;&#9;// Iniciar goroutine de polling&#10;&#9;go m.run()&#10;&#9;log.Printf(&quot;✅ [BoxCache] Worker iniciado correctamente&quot;)&#10;}&#10;&#10;// Stop detiene el worker de forma segura&#10;func (m *BoxCacheManager) Stop() {&#10;&#9;log.Printf(&quot; [BoxCache] Deteniendo worker...&quot;)&#10;&#9;m.cancel()&#10;&#9;log.Printf(&quot;✅ [BoxCache] Worker detenido&quot;)&#10;}&#10;&#10;// run ejecuta el loop de polling periódico&#10;func (m *BoxCacheManager) run() {&#10;&#9;ticker := time.NewTicker(m.interval)&#10;&#9;defer ticker.Stop()&#10;&#10;&#9;for {&#10;&#9;&#9;select {&#10;&#9;&#9;case &lt;-m.ctx.Done():&#10;&#9;&#9;&#9;return&#10;&#9;&#9;case &lt;-ticker.C:&#10;&#9;&#9;&#9;if err := m.refresh(); err != nil {&#10;&#9;&#9;&#9;&#9;log.Printf(&quot;❌ [BoxCache] Error en refresh periódico: %v&quot;, err)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;&#10;// refresh ejecuta la query y actualiza el caché atómicamente&#10;func (m *BoxCacheManager) refresh() error {&#10;&#9;// Protección contra refreshes simultáneos&#10;&#9;if !m.refreshing.CompareAndSwap(false, true) {&#10;&#9;&#9;return nil // Ya hay un refresh en curso, skip&#10;&#9;}&#10;&#9;defer m.refreshing.Store(false)&#10;&#10;&#9;startTotal := time.Now()&#10;&#10;&#9;// 1. Query a SQL Server&#10;&#9;ctx, cancel := context.WithTimeout(m.ctx, 10*time.Second)&#10;&#9;defer cancel()&#10;&#10;&#9;rows, err := m.ssmsManager.Query(ctx, db.SELECT_TOP_N_BOXES_FROM_CURRENT_PROCESO, m.cacheSize)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Printf(&quot;❌ [BoxCache] Error en query: %v&quot;, err)&#10;&#9;&#9;return fmt.Errorf(&quot;error en query: %w&quot;, err)&#10;&#9;}&#10;&#9;defer rows.Close()&#10;&#10;&#9;// 2. Leer resultados y construir map indexado por codCaja&#10;&#9;newBoxes := make(map[string]BoxData, m.cacheSize)&#10;&#9;rowCount := 0&#10;&#9;for rows.Next() {&#10;&#9;&#9;var box BoxData&#10;&#9;&#9;var nombreVariedad string // No se usa en BoxData, pero viene en la query&#10;&#9;&#9;if err := rows.Scan(&amp;box.Especie, &amp;box.Variedad, &amp;box.Calibre, &amp;box.Embalaje, &amp;box.Dark, &amp;nombreVariedad, &amp;box.CodCaja); err != nil {&#10;&#9;&#9;&#9;log.Printf(&quot;⚠️  [BoxCache] Error al escanear fila: %v&quot;, err)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#9;&#9;newBoxes[box.CodCaja] = box&#10;&#9;&#9;rowCount++&#10;&#9;}&#10;&#10;&#9;if len(newBoxes) == 0 {&#10;&#9;&#9;log.Printf(&quot;⚠️  [BoxCache] Query retornó 0 filas&quot;)&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;// 3. Swap atómico del caché&#10;&#9;m.mu.Lock()&#10;&#9;m.boxes = newBoxes&#10;&#9;m.mu.Unlock()&#10;&#10;&#9;// 4. Registrar métricas de tiempo&#10;&#9;totalDuration := time.Since(startTotal)&#10;&#9;m.mu2.Lock()&#10;&#9;m.lastRefreshDuration = totalDuration&#10;&#9;m.lastRefreshTime = time.Now()&#10;&#9;m.mu2.Unlock()&#10;&#10;&#9;log.Printf(&quot;✅ [BoxCache] Refresh OK: %d cajas en %.1fms&quot;, rowCount, totalDuration.Seconds()*1000)&#10;&#10;&#9;return nil&#10;}&#10;&#10;// GetBoxData busca una caja en el caché usando acceso directo O(1) al map&#10;// Retorna los datos y un bool indicando si se encontró&#10;func (m *BoxCacheManager) GetBoxData(codCaja string) (BoxData, bool) {&#10;&#9;m.mu.RLock()&#10;&#9;boxes := m.boxes&#10;&#9;m.mu.RUnlock()&#10;&#10;&#9;if len(boxes) == 0 {&#10;&#9;&#9;m.misses.Add(1)&#10;&#9;&#9;return BoxData{}, false&#10;&#9;}&#10;&#10;&#9;// Acceso directo O(1) al map por código de caja&#10;&#9;box, found := boxes[codCaja]&#10;&#10;&#9;if found {&#10;&#9;&#9;m.hits.Add(1)&#10;&#9;&#9;return box, true&#10;&#9;}&#10;&#10;&#9;// No encontrado&#10;&#9;m.misses.Add(1)&#10;&#10;&#9;return BoxData{}, false&#10;}&#10;&#10;// GetStats retorna las estadísticas del caché&#10;func (m *BoxCacheManager) GetStats() map[string]interface{} {&#10;&#9;hits := m.hits.Load()&#10;&#9;misses := m.misses.Load()&#10;&#9;total := hits + misses&#10;&#10;&#9;var ratio float64&#10;&#9;if total &gt; 0 {&#10;&#9;&#9;ratio = float64(hits) / float64(total) * 100&#10;&#9;}&#10;&#10;&#9;m.mu.RLock()&#10;&#9;cacheSize := len(m.boxes)&#10;&#9;m.mu.RUnlock()&#10;&#10;&#9;m.mu2.RLock()&#10;&#9;lastRefreshDuration := m.lastRefreshDuration&#10;&#9;lastRefreshTime := m.lastRefreshTime&#10;&#9;m.mu2.RUnlock()&#10;&#10;&#9;return map[string]interface{}{&#10;&#9;&#9;&quot;hits&quot;:                 hits,&#10;&#9;&#9;&quot;misses&quot;:               misses,&#10;&#9;&#9;&quot;total_searches&quot;:       total,&#10;&#9;&#9;&quot;hit_ratio_percent&quot;:    ratio,&#10;&#9;&#9;&quot;cache_size_current&quot;:   cacheSize,&#10;&#9;&#9;&quot;cache_size_max&quot;:       m.cacheSize,&#10;&#9;&#9;&quot;last_refresh_ms&quot;:      lastRefreshDuration.Milliseconds(),&#10;&#9;&#9;&quot;last_refresh_time&quot;:    lastRefreshTime.Format(&quot;2006-01-02 15:04:05&quot;),&#10;&#9;&#9;&quot;refresh_interval_sec&quot;: m.interval.Seconds(),&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package flow&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;log&quot;&#10;&#9;&quot;sync&quot;&#10;&#9;&quot;sync/atomic&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;API-DANSORT/internal/db&quot;&#10;)&#10;&#10;// BoxData representa los datos de una caja cacheados en memoria&#10;type BoxData struct {&#10;&#9;CodCaja  string&#10;&#9;Especie  string&#10;&#9;Calibre  string&#10;&#9;Variedad string&#10;&#9;Embalaje string&#10;&#9;Dark     int&#10;}&#10;&#10;// BoxCacheManager gestiona un caché en memoria de las últimas N cajas&#10;// del proceso actual, con acceso directo O(1) por código de caja&#10;type BoxCacheManager struct {&#10;&#9;ctx         context.Context&#10;&#9;cancel      context.CancelFunc&#10;&#9;ssmsManager *db.Manager&#10;&#10;&#9;// Caché indexado por codCaja para acceso O(1) directo&#10;&#9;boxes map[string]BoxData&#10;&#9;mu    sync.RWMutex&#10;&#10;&#9;// Configuración&#10;&#9;cacheSize  int           // Número de cajas a cachear (ej: 1000)&#10;&#9;interval   time.Duration // Intervalo de polling (ej: 2s)&#10;&#9;started    atomic.Bool   // Flag para evitar múltiples Start()&#10;&#9;refreshing atomic.Bool   // Flag para evitar refreshes simultáneos&#10;&#10;&#9;// Métricas&#10;&#9;hits   atomic.Int64 // Búsquedas exitosas en caché&#10;&#9;misses atomic.Int64 // Búsquedas fallidas (fallback a DB)&#10;&#10;&#9;// Observabilidad de tiempos&#10;&#9;lastRefreshDuration time.Duration // Tiempo del último refresh completo&#10;&#9;lastRefreshTime     time.Time     // Timestamp del último refresh&#10;&#9;mu2                 sync.RWMutex  // Mutex para métricas de tiempo&#10;}&#10;&#10;// NewBoxCacheManager crea una nueva instancia del gestor de caché de cajas&#10;func NewBoxCacheManager(ctx context.Context, ssmsManager *db.Manager, cacheSize int, interval time.Duration) *BoxCacheManager {&#10;&#9;workerCtx, cancel := context.WithCancel(ctx)&#10;&#10;&#9;if cacheSize &lt;= 0 {&#10;&#9;&#9;cacheSize = 500 // Default&#10;&#9;&#9;log.Printf(&quot;⚠️  [BoxCache] Tamaño de caché inválido, usando default: %d&quot;, cacheSize)&#10;&#9;}&#10;&#10;&#9;if interval &lt;= 0 {&#10;&#9;&#9;interval = 5 * time.Second // Default&#10;&#9;&#9;log.Printf(&quot;⚠️  [BoxCache] Intervalo inválido, usando default: %v&quot;, interval)&#10;&#9;}&#10;&#10;&#9;return &amp;BoxCacheManager{&#10;&#9;&#9;ctx:         workerCtx,&#10;&#9;&#9;cancel:      cancel,&#10;&#9;&#9;ssmsManager: ssmsManager,&#10;&#9;&#9;boxes:       make(map[string]BoxData, cacheSize),&#10;&#9;&#9;cacheSize:   cacheSize,&#10;&#9;&#9;interval:    interval,&#10;&#9;}&#10;}&#10;&#10;// Start inicia el worker de sincronización periódica&#10;func (m *BoxCacheManager) Start() {&#10;&#9;// Protección contra múltiples Start()&#10;&#9;if !m.started.CompareAndSwap(false, true) {&#10;&#9;&#9;log.Printf(&quot;⚠️  [BoxCache] Start() ya fue llamado, ignorando llamada duplicada&quot;)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;log.Printf(&quot; [BoxCache] Iniciando con configuración:&quot;)&#10;&#9;log.Printf(&quot;    Tamaño de caché: %d cajas (acceso O(1) directo por ID)&quot;, m.cacheSize)&#10;&#9;log.Printf(&quot;   ⏱️  Intervalo de polling: %v&quot;, m.interval)&#10;&#9;log.Printf(&quot;    Primera carga inmediata...&quot;)&#10;&#10;&#9;// Primera carga inmediata (bloqueante)&#10;&#9;if err := m.refresh(); err != nil {&#10;&#9;&#9;log.Printf(&quot;❌ [BoxCache] Error en carga inicial: %v&quot;, err)&#10;&#9;&#9;log.Printf(&quot;   ⚠️  El caché estará vacío hasta el próximo refresh exitoso&quot;)&#10;&#9;}&#10;&#10;&#9;// Iniciar goroutine de polling&#10;&#9;go m.run()&#10;&#9;log.Printf(&quot;✅ [BoxCache] Worker iniciado correctamente&quot;)&#10;}&#10;&#10;// Stop detiene el worker de forma segura&#10;func (m *BoxCacheManager) Stop() {&#10;&#9;log.Printf(&quot; [BoxCache] Deteniendo worker...&quot;)&#10;&#9;m.cancel()&#10;&#9;log.Printf(&quot;✅ [BoxCache] Worker detenido&quot;)&#10;}&#10;&#10;// run ejecuta el loop de polling periódico&#10;func (m *BoxCacheManager) run() {&#10;&#9;ticker := time.NewTicker(m.interval)&#10;&#9;defer ticker.Stop()&#10;&#10;&#9;for {&#10;&#9;&#9;select {&#10;&#9;&#9;case &lt;-m.ctx.Done():&#10;&#9;&#9;&#9;return&#10;&#9;&#9;case &lt;-ticker.C:&#10;&#9;&#9;&#9;if err := m.refresh(); err != nil {&#10;&#9;&#9;&#9;&#9;log.Printf(&quot;❌ [BoxCache] Error en refresh periódico: %v&quot;, err)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;&#10;// refresh ejecuta la query y actualiza el caché atómicamente&#10;func (m *BoxCacheManager) refresh() error {&#10;&#9;// Protección contra refreshes simultáneos&#10;&#9;if !m.refreshing.CompareAndSwap(false, true) {&#10;&#9;&#9;return nil // Ya hay un refresh en curso, skip&#10;&#9;}&#10;&#9;defer m.refreshing.Store(false)&#10;&#10;&#9;startTotal := time.Now()&#10;&#10;&#9;// VERIFICACIÓN: Asegurarse de que el manager de SSMS no sea nil&#10;&#9;if m.ssmsManager == nil {&#10;&#9;&#9;log.Printf(&quot;❌ [BoxCache] Error: ssmsManager es nil. El refresh no puede continuar.&quot;)&#10;&#9;&#9;return fmt.Errorf(&quot;ssmsManager no está inicializado&quot;)&#10;&#9;}&#10;&#10;&#9;// 1. Query a SQL Server&#10;&#9;ctx, cancel := context.WithTimeout(m.ctx, 10*time.Second)&#10;&#9;defer cancel()&#10;&#10;&#9;rows, err := m.ssmsManager.Query(ctx, db.SELECT_TOP_N_BOXES_FROM_CURRENT_PROCESO, m.cacheSize)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Printf(&quot;❌ [BoxCache] Error en query: %v&quot;, err)&#10;&#9;&#9;return fmt.Errorf(&quot;error en query: %w&quot;, err)&#10;&#9;}&#10;&#9;defer rows.Close()&#10;&#10;&#9;// 2. Leer resultados y construir map indexado por codCaja&#10;&#9;newBoxes := make(map[string]BoxData, m.cacheSize)&#10;&#9;rowCount := 0&#10;&#9;for rows.Next() {&#10;&#9;&#9;var box BoxData&#10;&#9;&#9;var nombreVariedad string // No se usa en BoxData, pero viene en la query&#10;&#9;&#9;if err := rows.Scan(&amp;box.Especie, &amp;box.Variedad, &amp;box.Calibre, &amp;box.Embalaje, &amp;box.Dark, &amp;nombreVariedad, &amp;box.CodCaja); err != nil {&#10;&#9;&#9;&#9;log.Printf(&quot;⚠️  [BoxCache] Error al escanear fila: %v&quot;, err)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#9;&#9;newBoxes[box.CodCaja] = box&#10;&#9;&#9;rowCount++&#10;&#9;}&#10;&#10;&#9;if len(newBoxes) == 0 {&#10;&#9;&#9;log.Printf(&quot;⚠️  [BoxCache] Query retornó 0 filas&quot;)&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;// 3. Swap atómico del caché&#10;&#9;m.mu.Lock()&#10;&#9;m.boxes = newBoxes&#10;&#9;m.mu.Unlock()&#10;&#10;&#9;// 4. Registrar métricas de tiempo&#10;&#9;totalDuration := time.Since(startTotal)&#10;&#9;m.mu2.Lock()&#10;&#9;m.lastRefreshDuration = totalDuration&#10;&#9;m.lastRefreshTime = time.Now()&#10;&#9;m.mu2.Unlock()&#10;&#10;&#9;log.Printf(&quot;✅ [BoxCache] Refresh OK: %d cajas en %.1fms&quot;, rowCount, totalDuration.Seconds()*1000)&#10;&#10;&#9;return nil&#10;}&#10;&#10;// GetBoxData busca una caja en el caché usando acceso directo O(1) al map&#10;// Retorna los datos y un bool indicando si se encontró&#10;func (m *BoxCacheManager) GetBoxData(codCaja string) (BoxData, bool) {&#10;&#9;m.mu.RLock()&#10;&#9;boxes := m.boxes&#10;&#9;m.mu.RUnlock()&#10;&#10;&#9;if len(boxes) == 0 {&#10;&#9;&#9;m.misses.Add(1)&#10;&#9;&#9;return BoxData{}, false&#10;&#9;}&#10;&#10;&#9;// Acceso directo O(1) al map por código de caja&#10;&#9;box, found := boxes[codCaja]&#10;&#10;&#9;if found {&#10;&#9;&#9;m.hits.Add(1)&#10;&#9;&#9;return box, true&#10;&#9;}&#10;&#10;&#9;// No encontrado&#10;&#9;m.misses.Add(1)&#10;&#10;&#9;return BoxData{}, false&#10;}&#10;&#10;// GetStats retorna las estadísticas del caché&#10;func (m *BoxCacheManager) GetStats() map[string]interface{} {&#10;&#9;hits := m.hits.Load()&#10;&#9;misses := m.misses.Load()&#10;&#9;total := hits + misses&#10;&#10;&#9;var ratio float64&#10;&#9;if total &gt; 0 {&#10;&#9;&#9;ratio = float64(hits) / float64(total) * 100&#10;&#9;}&#10;&#10;&#9;m.mu.RLock()&#10;&#9;cacheSize := len(m.boxes)&#10;&#9;m.mu.RUnlock()&#10;&#10;&#9;m.mu2.RLock()&#10;&#9;lastRefreshDuration := m.lastRefreshDuration&#10;&#9;lastRefreshTime := m.lastRefreshTime&#10;&#9;m.mu2.RUnlock()&#10;&#10;&#9;return map[string]interface{}{&#10;&#9;&#9;&quot;hits&quot;:                 hits,&#10;&#9;&#9;&quot;misses&quot;:               misses,&#10;&#9;&#9;&quot;total_searches&quot;:       total,&#10;&#9;&#9;&quot;hit_ratio_percent&quot;:    ratio,&#10;&#9;&#9;&quot;cache_size_current&quot;:   cacheSize,&#10;&#9;&#9;&quot;cache_size_max&quot;:       m.cacheSize,&#10;&#9;&#9;&quot;last_refresh_ms&quot;:      lastRefreshDuration.Milliseconds(),&#10;&#9;&#9;&quot;last_refresh_time&quot;:    lastRefreshTime.Format(&quot;2006-01-02 15:04:05&quot;),&#10;&#9;&#9;&quot;refresh_interval_sec&quot;: m.interval.Seconds(),&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>